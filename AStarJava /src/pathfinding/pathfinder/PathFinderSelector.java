package pathfinding.pathfinder;

import java.util.ArrayList;
import java.util.HashSet;
import java.util.List;
import java.util.Set;

import pathfinding.StatusEnum;
import pathfinding.data.structure.StructureSelector;
import pathfinding.map.TileMap;
import pathfinding.map.WeightedPoint;
import pathfinding.map.heuristic.HeuristicScheme;
import pathfinding.map.neighbor.NeighborSelector;

public abstract class PathFinderSelector {

    protected TileMap map;
	
	public WeightedPoint cursor;
	
	public long endTime;
	
	public long startTime;
	
	public long totalTime;
	
	public StructureSelector<WeightedPoint> openSet;
	
	public Set<WeightedPoint> closedSet;
	
	public HeuristicScheme heuristic;
	
	public NeighborSelector neighborSelector;
	 
	public StatusEnum status;
	
	public WeightedPoint tail;
	
	public boolean initialStep;

	
	public PathFinderSelector(TileMap map) {
		reset(map);
	}
	
	public TileMap getMap() {
		// TODO Auto-generated method stub
		return map;
	}

	
	public WeightedPoint getStart() {
		// TODO Auto-generated method stub
		return map.getStart();
	}

	
	public WeightedPoint getGoal() {
		// TODO Auto-generated method stub
		return map.getGoal();
	}

	
	public WeightedPoint getCursor() {
		// TODO Auto-generated method stub
		return cursor;
	}

	
	public int getSeed() {
		// TODO Auto-generated method stub
		return map.getSeed();
	}

	
	public long getTime() {
		// TODO Auto-generated method stub
		return endTime - startTime;
	}

	
	public void setOpenSet(StructureSelector<WeightedPoint> structure) {
		// TODO Auto-generated method stub
		this.openSet = structure;
	}


	
	public StructureSelector<WeightedPoint> getOpenSet() {
		// TODO Auto-generated method stub
		return openSet;
	}

	
	public Set<WeightedPoint> getClosedSet() {
		// TODO Auto-generated method stub
		return closedSet;
	}

	
	public void setHeuristic(HeuristicScheme heuristic) {
		// TODO Auto-generated method stub
		this.heuristic = heuristic;
	}

	
	public HeuristicScheme getHeuristic() {
		// TODO Auto-generated method stub
		return heuristic;
	}

	
	public void setNeighborSelector(NeighborSelector neighborSelector) {
		// TODO Auto-generated method stub
		this.neighborSelector = neighborSelector;
	}

	
	public NeighborSelector getNeighbor() {
		// TODO Auto-generated method stub
		return neighborSelector;
	}

	
	public void reset() {
		// TODO Auto-generated method stub
		reset(this.map, this.heuristic, this.neighborSelector, this.openSet);
	}

	
	public void reset(TileMap map) {
		// TODO Auto-generated method stub
		reset(map, this.heuristic, this.neighborSelector, this.openSet);
	}

	
	public void reset(StructureSelector<WeightedPoint> structure) {
		// TODO Auto-generated method stub
		reset(this.map, this.heuristic, this.neighborSelector, structure);
	}

	
	public void reset(TileMap map, HeuristicScheme heuristic, NeighborSelector neighborSelector,
			StructureSelector<WeightedPoint> structure) {
		// TODO Auto-generated method stub
		this.map = map;

        this.cursor = null;

        this.heuristic = heuristic;
        this.neighborSelector = neighborSelector;

        this.initialStep = true;

        this.status = StatusEnum.RUNNING;

        this.openSet = structure;
        this.closedSet = new HashSet<WeightedPoint>();
	}

	
	public void step() {
		// TODO Auto-generated method stub
		status = stepInternal();
	}

    //Run through the next step in the algorithm. Each step represents investigating another possible point on the path
    public abstract StatusEnum stepInternal();
   

       
    public StatusEnum solve() {
		// TODO Auto-generated method stub
		while (status == StatusEnum.RUNNING)
        {
            step();
        }
        return status;
	}

	
	public StatusEnum getStatus() {
		// TODO Auto-generated method stub
		return status;
	}

	
	public List<WeightedPoint> getPath() {
		// TODO Auto-generated method stub
		return getPath(this.tail);
	}

    //Constructs and returns a List version of the linked list generated by the algorithm from the specified cursor point
    public List<WeightedPoint> getPath(WeightedPoint cursor)
    {
        List<WeightedPoint> path = new ArrayList<WeightedPoint>();
        while (cursor != null)
        {
            path.add(path.size(), cursor);
            cursor = cursor.getPrev();
        }
        return path;
    }
	
}